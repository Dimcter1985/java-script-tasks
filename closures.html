<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    8
    <div class="buttons">
      <button class="btn">0</button>
      <button class="btn">0</button>
      <button class="btn">0</button>
    </div>
    <br />
    9
    <div class="paragrafs">
      <p class="txt">asasdfsdfdfdfdfdsfdfsdfds</p>
      <p class="txt">ghfhfgjghjghjghjghjghjh</p>
      <p class="txt">rtyrtyrtytrytrytryyertyrtrt</p>
    </div>
    <br />

    10
    <button class="btn2">Фибоначчи</button><span class="txt2"></span>
    <button class="btn2">Фибоначчи</button><span class="txt2"></span>
    <button class="btn2">Фибоначчи</button><span class="txt2"></span>
    <br /><br />

    11
    <button class="btn3">push</button>
    <script>
      //1 Если переменная a больше нуля - то в ggg запишем функцию, которая выводит один !, иначе запишем функцию, которая выводит два !
      (function () {
        let a = 4;
        let ggg = "";

        if (a > 0) {
          ggg = function () {
            return "!";
          };
        } else {
          ggg = function () {
            return "!!";
          };
        }

        console.log(ggg());
      })();

      //2 Функция ggg принимает 2 параметра: число и анонимную функцию, которая возводит число в квадрат. Возведите число в 4-тую степень с помощью ggg.
      (function () {
        let ggg = function (n, f) {
          return f(n);
        };
        funcNew = function (a) {
          return Math.pow(a, 2);
        };
        num = 7;
        console.log(ggg(ggg(num, funcNew), funcNew));
      })();

      //3 Функция ggg принимает 2 параметра: анонимную функцию, которая возвращает 3 и анонимную функцию, которая возвращает 4. Верните результатом функции ggg сумму 3 и 4.
      (function () {
        let ggg = function (f1, f2) {
          return f1() + f2();
        };

        let num1 = function () {
          return 3;
        };

        let num2 = function () {
          return 4;
        };
        console.log(ggg(num1, num2));
      })();

      //4 Дана функция ggg. Она требует первым параметром число, вторым функцию, которая возводит в квадрат, а третьим параметром функцию, которая возводит в куб. Эти функции есть как Function Declaration - kvadrat, kub. Пусть функция ggg вернет сумму квадрата и куба числа.
      (function () {
        let ggg = function (number, square, сube) {
          return square(number) + сube(number);
        };

        let n = 5;

        function kvadrat(number) {
          return Math.pow(number, 2);
        }

        function kub(number) {
          return Math.pow(number, 3);
        }

        console.log(ggg(n, kvadrat, kub));
      })();

      //5 Сделайте функцию each, которая первым параметром принимает массив, а вторым - функцию, которая применится к каждому элементу массива. Функция each должна вернуть измененный массив.
      (function () {
        let array = [1, 2, 3, 4];

        function changeArr(array) {
          let newArr = [];
          for (let i = 0; i < array.length; i++) {
            newArr[i] = array[i] + 1;
          }
          return newArr;
        }

        let each = function (arr, func) {
          return func(arr);
        };

        console.log(each(array, changeArr));
      })();

      //6 Сделайте функцию each, которая первым параметром принимает массив, а вторым - массив функций, которые по очереди применятся к каждому элементу массива: к первому элементу массива - первая функция, ко второму - вторая и так далее пока функции в массиве не закончатся, после этого возьмется первая функция, вторая и так далее по кругу
      (function () {
        let each = function (arr, funcArr) {
          for (let i = 0; i < arr.length; i++) {
            for (let j = 0; j < funcArr.length; j++) {
              arr[i] = funcArr[j](arr[i]);
            }
          }
          return arr;
        };

        let f1 = function (a) {
          return a + 3;
        };
        let f2 = function (a) {
          return a + 2;
        };
        let f3 = function (a) {
          return a + 1;
        };

        let numbers = [1, 2, 3, 4, 5];

        let functions = [f1, f2, f3];

        console.log(each(numbers, functions));
      })();

      //7  Сделайте функцию, которая считает и выводит количество своих вызовов.
      (function () {
        let i = 1;
        function counter() {
          return i++;
        }

        console.log(counter());
        console.log(counter());
        console.log(counter());
      })();

      //8 Даны кнопки. Привяжите к каждой кнопке событие по клику, которое будет считать количество нажатий по кнопке и выводить его в текст кнопки. Количество нажатий для каждой кнопки должно хранится в замыкании
      (function () {
        let buttons = document.querySelectorAll(".btn");
        let n = 1;
        function counter() {
          return n++;
        }

        buttons.forEach((el) => {
          el.addEventListener("click", () => {
            el.innerHTML = counter();
          });
        });
      })();

      //9 Дан массив цветов. Даны абзацы. По первому нажатию на абзац он должен покраситься в первый цвет из массива, по второму нажатию - во второй и так далее. Все абзацы работают независимо.

      (function () {
        let colors = ["red", "blue", "green"];
        let txt = document.querySelectorAll(".txt");

        let showColor = function () {
          let index = 0;
          return function () {
            this.style.color = colors[index];
            index++;
            if (index === colors.length) {
              index = 0;
            }
          };
        };

        txt.forEach((el) => {
          el.addEventListener("click", showColor());
        });
      })();

      //10  Даны кнопки. Каждая кнопка по нажатию на нее выводить следующее число Фибоначчи. Кнопки работают независимо. Решить через замыкания.
      (function () {
        let btn = document.querySelectorAll(".btn2");

        let fibonachhi = function () {
          let a = 0;
          let b = 1;
          let temp = null;
          return function () {
            this.nextElementSibling.innerHTML = a;
            temp = a;
            a = b;
            b = temp + a;
          };
        };

        btn.forEach((el) => {
          el.addEventListener("click", fibonachhi());
        });
      })();

      //11 Сделайте функцию, каждый вызов который будет генерировать случайные числа от 1 до 100, но так, чтобы они не повторялись, пока не будут перебраны все числа из этого промежутка. Решите задачу через замыкания - в замыкании должен хранится массив чисел, которые уже были сгенерированы функцией
      (function () {
        let random = function () {
          let usedNums = [];
          return function () {
            let newNum = Math.floor(Math.random() * 100 + 1);

            for (let i = 0; i < usedNums.length; i++) {
              if (usedNums[i] === newNum) {
                console.log("повтор!!!!!");
                return;
              }
            }
            console.log(newNum);
            usedNums.push(newNum);
            console.log(usedNums);
          };
        };

        let btn = document.querySelector(".btn3");
        btn.addEventListener("click", random());
      })();
    </script>
  </body>
</html>
